
    //         // Create a KD-Tree
    // pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);

    // // Output has the PointNormal type in order to store the normals calculated by MLS
    // pcl::PointCloud<pcl::PointXYZ>::Ptr mls_points(new pcl::PointCloud<pcl::PointXYZ>);
    // // Init object (second point type is for the normals, even if unused)
    // pcl::MovingLeastSquares<pcl::PointXYZ, pcl::PointXYZ> mls;

    // // Set parameters
    // mls.setInputCloud (cloud_filtered);
    // //mls.performUpsampling(*mls_points);
    // mls.setPolynomialOrder (2);
    // mls.setSearchMethod (tree);
    // mls.setSearchRadius (0.3);
    // mls.setComputeNormals (false);
    // //mls.setUpsamplingRadius(2.0);
    // // mls.setUpsamplingStepSize(0.5); // localPlane
    // //mls.setUpsamplingMethod (pcl::MovingLeastSquares<pcl::PointXYZ, pcl::PointXYZ>::UpsamplingMethod::VOXEL_GRID_DILATION);
    // mls.setDilationIterations (2);
    // //mls.setUpsamplingMethod (pcl::MovingLeastSquares<pcl::PointXYZ, pcl::PointXYZ>::UpsamplingMethod::SAMPLE_LOCAL_PLANE);

    // // mls.setUpsamplingRadius (1.0f);
    // // mls.setUpsamplingStepSize (1.5f);
    // //mls.setDilationIterations (0);
    //  mls.setDilationVoxelSize (0.1f);

    // // Reconstruct
    // //mls.process (*mls_points);

    // pcl::visualization::PCLVisualizer::Ptr viewer (new pcl::visualization::PCLVisualizer ("Extracted Holes"));
    // viewer->setBackgroundColor (0, 0, 0);

    // pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> color3(mls_points, 144, 144, 255);
    // viewer->addPointCloud<pcl::PointXYZ> (mls_points, color3, "cloud");

    // while (!viewer->wasStopped ()) {viewer->spinOnce ();}


    // Smoothen Surface
