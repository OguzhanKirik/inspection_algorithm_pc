    


        /*
        //#######################
            // for visualization
        pcl::PointXYZ p1{hole_coeeffecients.at(0),hole_coeeffecients.at(1),hole_coeeffecients.at(2)};

        Eigen::Vector3f point_local{0,10,0};
        Eigen::Vector3f point_local2global = t * point_local;
        std::cout << point_local2global << std::endl;
        pcl::PointXYZ p_{point_local2global.x(),point_local2global.y(),point_local2global.z()};
        Eigen::Vector3f p__ = p_.getVector3fMap()  +  p1.getVector3fMap();
        pcl::PointXYZ p2{p__.x(),p__.y(),p__.z()};

        add_lines.emplace_back(p1);
        add_lines.emplace_back(p2);
        // for visualization
        //#######################
        */

/*
    //#######################
    // Show bounding boxes, center and normals of the detected holes
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ> (cloudPath, *cloud) == -1){
        throw std::runtime_error("Couldn't read cloud pcd file \n");}
    pcl::visualization::PCLVisualizer::Ptr viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
    viewer->setBackgroundColor (0, 0, 0);
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> color1(cloud_BB_all, 255, 255, 0);
    
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> color3(cloud, 144, 144, 255);
    viewer->addPointCloud<pcl::PointXYZ> (cloud, color3, "cloud");
    viewer->addPointCloud<pcl::PointXYZ> (cloud_BB_all, color1, "bb");
    for (int i = 1; i < add_lines.size(); i+=2){
        viewer->addLine(add_lines.at(i-1),add_lines.at(i),122.0,133.0,250.0,cv::format("line%d",i));
    }


    
    std::vector<pcl::PointXYZ> add_arrows;
    for (size_t i = 0; i < detectedHoles.size(); i++){
    
        Eigen::Vector3f position_{detectedHoles.at(i).position_aligned[0],detectedHoles.at(i).position_aligned[1],(detectedHoles.at(i).position_aligned[2]+10)};
        Eigen::Vector3f position_shift{0,0,-10};
        Eigen::Vector3f position_second = detectedHoles.at(i).rotation_matrix * position_shift;
        Eigen::Vector3f position_second_= position_ + position_second;
        pcl::PointXYZ p_second{position_second_[0],position_second_[1],position_second_[2]};
        pcl::PointXYZ p_first{detectedHoles.at(i).position_aligned[0],detectedHoles.at(i).position_aligned[1],detectedHoles.at(i).position_aligned[2]};
        add_arrows.emplace_back(p_first);
        add_arrows.emplace_back(p_second);
        
    }
    
    for (int i = 1; i < add_arrows.size(); i+=2){
            viewer->addArrow(add_arrows.at(i-1),add_arrows.at(i),90.0,4.0,90.0,cv::format("line_%d",i));
    }
    
    while (!viewer->wasStopped ()) {viewer->spinOnce ();}    
     //#######################
        */
