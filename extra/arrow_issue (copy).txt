   //            pcl::PointCloud<pcl::PointXYZ>::Ptr pilot_holes( new pcl::PointCloud<pcl::PointXYZ>);
    //     for (size_t i = 0; i < inspected_drillTargets_5.size(); i++){
    //         if (inspected_drillTargets_5.at(i).differentCluster == false && inspected_drillTargets_5.at(i).misPrediction == false && inspected_drillTargets_5.at(i).unpiloted == false){
    //             pilot_holes->points.emplace_back(inspected_drillTargets_5.at(i).position_aligned[0],inspected_drillTargets_5.at(i).position_aligned[1],inspected_drillTargets_5.at(i).position_aligned[2]);
    //         }
    //     }
        
    //     float total_dev = 0.0f;
    //     int count = 0;

    // for (size_t i = 0; i < inspected_drillTargets_4.size(); i++){
    //     if (inspected_drillTargets_4.at(i).differentCluster == false && inspected_drillTargets_4.at(i).misPrediction == false && inspected_drillTargets_4.at(i).unpiloted == false){

    //         pcl::PointXYZ searchPoint{inspected_drillTargets_4.at(i).position_aligned[0],inspected_drillTargets_4.at(i).position_aligned[1],inspected_drillTargets_4.at(i).position_aligned[2]};
    //         float resolution = 128.0f;
    //         pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree (resolution);
    //         octree.setInputCloud (pilot_holes);
    //         octree.addPointsFromInputCloud ();

    //         int K = 1; // closest neighbour,
    //         std::vector<int> pointIdxNKNSearch;
    //         std::vector<float> pointNKNSquaredDistance;

    //         if (octree.nearestKSearch (searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) > 0){
    //             if( std::sqrt(pointNKNSquaredDistance[0]) < params.maxCorrespondenceDistance)  {
    //                  Eigen::Vector3f position_matched{(*pilot_holes)[ pointIdxNKNSearch[0] ].x ,
    //                 (*pilot_holes)[ pointIdxNKNSearch[0] ].y,
    //                 (*pilot_holes)[ pointIdxNKNSearch[0] ].z};
    //                     std::cout << inspected_drillTargets_4.at(i).ID << std::endl;
    //                     Eigen::Vector3f diff = inspected_drillTargets_4.at(i).position_aligned - position_matched;
    //                     float dev = (std::sqrt(std::pow(diff.x(),2)+std::pow(diff.y(),2)+std::pow(diff.z(),2)));
    //                     std::cout << "dev" << dev << std::endl;

    //                     total_dev += dev;
    //                     count++;
    //                 pcl::PointCloud<pcl::PointXYZ>::iterator index = pilot_holes->begin(); // delete the point
    //                 pilot_holes->erase(index + pointIdxNKNSearch[0]);
    //             }  
    //          }
    //     }
    //     }
   
//         float mean_error = total_dev / count;

//         std::cout << "mean error " << audit_id.at(i) <<" : "<< mean_error << std::endl;


// }




        // std::vector<drillTarget> inspected_drillTargets = startInspection(boundingBoxes,drillTargets_CAD,params,cloudPath);

        
       // std::string writeFilePath =  params.auditFolder + cv::format("/output/drill_targets_%d.txt",audit_id.at(i));
       // writeDetectionandInspection(writeFilePath,inspected_drillTargets);

    //     // std::vector<drillTarget> drillTargetCAD_set = setParameters(drillTargets_CAD);
    //     // Eigen::Affine3f sensorPose_ = calculateProfilometerPose(drillTargetCAD_set,params);
    //     // pcl::PointCloud<pcl::PointXYZ>::Ptr border_points = createRangeImageBorderExtaction(drillTargetCAD_set,params,sensorPose_,cloudPath); // Extract border points
    //     // showBorderPoints(border_points);

    //     if(audit_id.at(i) == 12 ){
    //          inspected_drillTargets_12 = (startInspection(boundingBoxes,drillTargets_CAD,params,cloudPath));
    //         //std::string writeFilePath =  params.auditFolder + cv::format("/output/drill_targets_%d.txt",audit_id.at(i));
    //         //     writeDetectionandInspection(writeFilePath,inspected_drillTargets_12);

    //     }else{
    //         inspected_drillTargets_33 = (startInspection(boundingBoxes,drillTargets_CAD,params,cloudPath));
    //              // std::string writeFilePath =  params.auditFolder + cv::format("/output/drill_targets_%d.txt",audit_id.at(i));
    //              //writeDetectionandInspection(writeFilePath,inspected_drillTargets_33);
    //              }

    //     // std::vector<drillTarget> average_Points;
    //     // for (auto & point : inspected_drillTargets_12){
    //     //     if(point.differentCluster == false && point.misPrediction == false){
    //     //         for (size_t i = 0; i < inspected_drillTargets_33.size(); i++){
    //     //             if( point.ID == inspected_drillTargets_33.at(i).ID){
    //     //                 drillTarget average_P;
    //     //                 average_P.cluster =point.cluster - inspected_drillTargets_33.at(i).cluster; 
    //     //                 average_P.ID =  point.ID;
    //     //                 average_P.position_aligned =  (point.position_aligned + inspected_drillTargets_33.at(i).position_aligned)/2;
    //     //                 average_P.quartenion_cad = point.quartenion_cad;
    //     //                 average_Points.emplace_back(average_P);
    //     //             }

    //     //     }
    //     //     }
            
    //     // }
